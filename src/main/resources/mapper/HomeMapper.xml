<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.example.demo.domain.mapper.HomeMapper">

    <resultMap id="BannerMap" type="com.example.demo.domain.Banner">
        <!-- id="BannerMap" : 이 매핑의 이름 -->
        <!-- <select id="findMainBanner" resultMap="BannerMap"> 에서 사용됨 -->
        <!-- type="com.example.demo.domain.Banner" : SQL 결과를 담을 자바 객체 타입. -->
        <!-- 즉, 최종 결과는 Banner 객체가 됨 -->
        <id property="id" column="id"/>
        <!-- DB 컬럼 id -->
        <!-- -> Banner.id 필드에 매핑 -->
        <!-- 이 값으로 객체 동일성 판단 -->
        <!-- 단건 조회라도 반드시 써주는게 정석 -->
        <result property="title" column="title"/>
        <!-- DB의 title 컬럼 값 -->
        <!-- -> Banner.title 필드에 넣음 -->
        <!-- 문자열 그대로 1:1 매핑 -->
        <result property="subtitle" column="subtitle"/>
        <!-- DB의 subtitle -> Banner.subtitle -->
        <!-- 의미 없음. 가공 없음 -->
        <result property="imageUrl" column="image_url"/>
        <!-- DB 컬럼 image_url -->
        <!-- -> Banner.imageUrl 필드에 매핑 -->
        <!-- DB 는 snake_case (image_url) -->
        <!-- 자바는 camelCase (imageUrl) -->
        <!-- 그래서 resultMap 이 필요한 전형적인 예 -->
    </resultMap>

    <!--
    Controller 에서 Service 의 getMainBanner() 메서드를 호출하려고 하면 최종적으로 이곳으로 보내진다. id가 findMainBanner 이기 때문
    결과 : SQL 실행 -> DB 에서 결과 row 1개 나옴
    컨트롤러가 받는 건 이거:
    Banner {
        imageUrl="/images/time/1.png",
        title="메인 배너",
        link="/event"
    }
    -->
    <select id="findMainBanner" resultMap="BannerMap">
        <!--image_url = /images/time/1.png-->
        <!--title = 메인 배너-->
        <!--link = /event-->

        SELECT id, title, subtitle, image_url
        <!-- banner 테이블에서 이 네 컬럼만 가져옴. 쓸데없는 컬럼은 가져오지 않는게 정석-->
        FROM banner
        <!-- 대상 테이블-->
        ORDER BY id DESC
        <!-- id 기준 내림차순 보통 id가 auto_increment라서 가장 최근에 등록된 배너가 맨 위-->
        LIMIT 1
        <!-- 결과를 딱 1행만. 그래서 반환 타입도 Banner 하나-->
    </select>


    <resultMap id="RecommendationMap" type="com.example.demo.domain.Recommendation">
        <!--id="RecommendationMap" 이 매핑의 이름-->
        <!--type=Recommendation : 최종적으로 만들 객체 타입-->
        <id property="id" column="r_id"/>
        <!--r_id 컬럼 값이 같으면 MyBatis는 같은 Recommendation 객체라고 판단. 이게 없으면 박스 개수만큼 Recommendation이 중복 생성됨-->
        <result property="name" column="name"/>
        <result property="url" column="url"/>
        <result property="seller" column="seller"/>
        <!--부모 객체의 일반 필드들-->
        <!--SQL 결과의 각 컬럼은 Recommendation 객체의 필드에 꽂는다.-->
        <collection property="boxes"
                    ofType="com.example.demo.domain.RecommendationBox">
            <!--반환 시켜주는 곳인 Recommendation에 있는 private List<RecommendationBox> boxes;-->
            <!--의미: Recommendation.boxes (Recommendation 에 있는 boxes. List 형태로 있음. 여기서는 RecommendationBox 객체만 담을 수 있음. 여기서 RecommendationBox 는 색 조합표 사진 한개를 말하는 것)-->
            <!--타입은 List<RecommendationBox>-->
            <!--여러 행 (사진 하나하나) 을 모아서 하나의 리스트로 만들어라-->
            <id property="id" column="b_id"/>
            <!--box의 id = 봄 여름 가을 겨울 을 자바 객체의 id필드에 매핑-->
            <!--왜냐하면 이 프로젝트의 데이터 베이스에선 b_id 가 다르다는것은 -> 다른 박스. 이게 없으면 같은 박스가 여러 번 들어갈 수 있음 (객체 동일성 판단하는데 쉬움) 같은 객체인지 판단이 안되-->
            <!--property는 값을 넣을 자바 객체의 이름-->

            <result property="recommendationId" column="recommendation_id"/>
            <result property="sortOrder" column="sort_order"/>
            <result property="imageUrl" column="image_url"/>
            <!--자식 객체 필드 매핑-->
        </collection>
    </resultMap>
    <!--실제 SQL 결과 -> 객체 변환 예시-->
    <!--SQL 결과 (JOIN)-->
    <!--| r_id | name  | b_id | image_url |-->
    <!--| 1    | 봄웜톤 |  10  |  a.png    |-->
    <!--| 1    | 봄웜톤 |  11  |  b.png    |-->
    <!--| 1    | 봄웜톤 |  12  |  c.png    |-->

    <select id="findRecommendations" resultMap="RecommendationMap">
        <!-- id="findRecommendations" 는 Mapper 메서드 이름.
        보통: List<Recommendation> findRecommendations();-->
        SELECT
        <!--부모 PK-->
        r.id AS r_id,
        <!--여기서 recommendation의 id를 r_id 라고 지정. 그 값은 resultMap 인 RecommendationMap 에서도 똑같이 쓰임. (정확히 맞춤)-->
        r.name, r.url, r.seller,
        r.bg_color_hex,

        <!--자식 PK-->
        b.id AS b_id,
        b.recommendation_id,
        b.sort_order,
        b.image_url

        <!--recommendation 을 r 하고 이 테이블을 기준점으로 한다.-->
        <!--FROM recommendation r-->

        <!--왼쪽 테이블의 모든 행을 결과에 포함시키고, 오른쪽 테이블은 JOIN 조건이 일치( 주로 값이 같은가? ) 할 때만 붙인다. 일치하지 않으면 오른쪽 컬럼들은 NULL 이 된다.-->
        <!--반대로 INNER JOIN 이면 box가 없으면 아예 추천도 결과에서 사라진다.-->
        <!--왼쪽 테이블의 모든 행을 기준으로 가져오고, 오른쪽 테이블은 JOIN 조건이 맞는 행만 붙인다. 조건이 안 맞으면 오른쪽 컬럼은 NULL로 나온다.-->
        <!--LEFT JOIN recommendation_box b-->

        <!--오른쪽에 있는 테이블을 왼쪽에 있는 테이블에 옮기는데 이때 조건이 맞아야한다.-->
        <!--LEFT JOIN 할것의 조건은 ON 에 다가 다 적는다.-->
        <!--여기서는 id가 일치할때가 조건이다.-->
        <!--ON b.recommendation_id = r.id-->

        <!-- r(recommendation)은 id 순서대로 b(box)는 sort_order 순서대로-->

        FROM (
        SELECT *
        FROM recommendation
        ORDER BY
        CASE TRIM(tone_type)
        WHEN 'spring_warm' THEN 1
        WHEN 'summer_cool' THEN 2
        WHEN 'fall_warm' THEN 3
        WHEN 'winter_cool' THEN 4
        ELSE 99
        END
        LIMIT 4
        ) r
        LEFT JOIN recommendation_box b
        ON b.recommendation_id = r.id

        ORDER BY
        CASE TRIM(r.tone_type)
        WHEN 'spring_warm' THEN 1
        WHEN 'summer_cool' THEN 2
        WHEN 'fall_warm' THEN 3
        WHEN 'winter_cool' THEN 4
        ELSE 99
        END,
        b.sort_order ASC


        <!--r.id ASC, b.sort_order ASC-->

        <!--이건 JOIN 된 결과. 그니까 JOIN 왼쪽에 있던 recommendation만 20개를 의미하는 것이다.-->
        <!--결국 recommendation 만을 의미하는것이다.-->

    </select>

    <!--MyBatis 가 SQL 실행 각 row 를 보고 컬럼 이름과 필드 이름을 자동 매핑
    DB 컬럼의 id 가 Recommendation 필드의 id 하나랑 동일
    여기서 findRecommendations 은 mapper 의 findRecommendations 과 동일함-->

    <!--XML 은 단지 1) SQL 문자열을 보관 매핑 2) 규칙을 정의 3) 파라미터 바인딩 규칙을 지정-->
    <!--1) SQL 실행은 DB 에서 일어남-->
    <!--2) SELECT id, title, subtitle FROM banner; -> id:1, title: A, subtitle: B-->
    <!--3) MyBatis가 row(INSERT로 넣은 값들 중 한줄) 1개 집음 -> 첫번째 row를 하나 꺼냄 이 row에는 칼럼 이름 + 값이 있음-->
    <!--4) 자바 객체를 하나 만들기 Banner banner = new Banner();-->
    <!--5) DB 컬럼 이름 : id <-> 자바 필드 이름 : id -->
    <!--Banner 객체에 있는 id라는 필드값에 1을 넣는다.-->

    <select id="findBoxInfos" resultType="com.example.demo.domain.BoxInfo">
        SELECT id, label, value
        FROM box_info
        ORDER BY id ASC
    </select>


    <!-- Banner CRUD -->
    <select id="findAllBanners" resultMap="BannerMap">
        SELECT id, title, subtitle, image_url
        FROM banner
        ORDER BY id DESC
    </select>

    <select id="findBannerById" resultMap="BannerMap">
        SELECT id, title, subtitle, image_url
        FROM banner
        WHERE id = #{id}
    </select>

    <insert id="insertBanner" parameterType="com.example.demo.domain.Banner" useGeneratedKeys="true" keyProperty="id">
        INSERT INTO banner(title, subtitle, image_url)
        VALUES (#{title}, #{subtitle}, #{imageUrl})
    </insert>

    <update id="updateBanner" parameterType="com.example.demo.domain.Banner">
        UPDATE banner
        SET title = #{title},
        subtitle = #{subtitle},
        image_url = #{imageUrl}
        WHERE id = #{id}
    </update>

    <delete id="deleteBanner">
        DELETE FROM banner WHERE id = #{id}
    </delete>

    <!-- Recommendation CRUD -->
    <select id="findAllRecommendations" resultType="com.example.demo.domain.Recommendation">
        SELECT id, name, url, seller
        FROM recommendation
        ORDER BY id DESC
    </select>

    <select id="findRecommendationById" resultType="com.example.demo.domain.Recommendation">
        SELECT id, name, url, seller
        FROM recommendation
        WHERE id = #{id}
    </select>

    <insert id="insertRecommendation" parameterType="com.example.demo.domain.Recommendation" useGeneratedKeys="true"
            keyProperty="id">
        INSERT INTO recommendation(name, url, seller)
        VALUES (#{name}, #{url}, #{seller})
    </insert>

    <update id="updateRecommendation" parameterType="com.example.demo.domain.Recommendation">
        UPDATE recommendation
        SET name = #{name},
        url = #{url},
        seller = #{seller}
        WHERE id = #{id}
    </update>

    <delete id="deleteRecommendation">
        DELETE FROM recommendation WHERE id = #{id}
    </delete>

    <!-- BoxInfo CRUD -->
    <select id="findAllBoxInfos" resultType="com.example.demo.domain.BoxInfo">
        SELECT id, label, value
        FROM box_info
        ORDER BY id DESC
    </select>

    <select id="findBoxInfoById" resultType="com.example.demo.domain.BoxInfo">
        SELECT id, label, value
        FROM box_info
        WHERE id = #{id}
    </select>

    <insert id="insertBoxInfo" parameterType="com.example.demo.domain.BoxInfo" useGeneratedKeys="true" keyProperty="id">
        INSERT INTO box_info(label, value)
        VALUES (#{label}, #{value})
    </insert>

    <update id="updateBoxInfo" parameterType="com.example.demo.domain.BoxInfo">
        UPDATE box_info
        SET label = #{label},
        value = #{value}
        WHERE id = #{id}
    </update>

    <delete id="deleteBoxInfo">
        DELETE FROM box_info WHERE id = #{id}
    </delete>


</mapper>